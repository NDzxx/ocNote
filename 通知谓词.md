# 通知谓词

##通知
类似android的广播，不像kvo只能监视属性，可以互相交互

还是护士和小孩的那个例子

Children.h
```
#import <Foundation/Foundation.h>  
  
@interface Children : NSObject  
  
@property NSInteger *hapyValue;  
  
  
@end
```
children.m
```
  
#import "Children.h"  
  
@implementation Children  
  
- (id) init{  
    self = [super init];  
    if(self != nil){  
        //启动定时器  
        [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(timerAction) userInfo:nil repeats:YES];  
        self.hapyValue= 100;  
    }  
    return self;  
}  
  
- (void) timerAction:(NSTimer *) timer{
    _hapyValue--;  
    NSLog(@"%@",_hapyValue);  
    if(_hapyValue <80){  
        //发送通知  
        //这里和KVO的区别，我们可以手动的发送通知  
        //注意通知的名称，传递的参数必须和定义通知的地方的参数值要一致  
        //将Children对象传递过去  
        
        // 第一个参数：通知的名称，这个名称必须和后面接受通知的名称一致
        //第二个参数：可以传递的一个参数对象
        [[NSNotificationCenter defaultCenter] 
        postNotificationName:@"happyValueNotification" object:self];  
    }  
  
}  
 
@end
```
Nure.h
```
#import <Foundation/Foundation.h>  
  
@interface Nure : NSObject  
  
@end 
```
Nurse.m
```
#import "Nure.h"  
#import "Children.h"  
  
@implementation Nure  
  
- (id) init{  
    self = [super init];  
    if(self != nil){  
          
        //监听一个通知，当收到通知时，调用notificationAction方法  
        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(notificationAction) name:@"happyValueNotification" object:nil];  
          
    }  
    return self;  
}  
  
  
- (void) notificationAction:(NSNotification *)notification{  
    //这里我们拿到Children对象进行操作  
    Children *children = notification.object;  
    NSLog(@"触发通知");  
}  
  
- (void)dealloc{  
    //移除指定的通知，不然会造成内存泄露  
    [[NSNotificationCenter defaultCenter] removeObserver:self name:@"happyValueNotification" object:nil];  
      
    //Children对象可以添加多个通知  
    //下面的方法是可以移除Children中所有通知  
    [[NSNotificationCenter defaultCenter] removeObserver:self];  
}  
  
@end  
```

